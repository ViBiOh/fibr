// Code generated by MockGen. DO NOT EDIT.
// Source: metadata.go

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	model "github.com/ViBiOh/absto/pkg/model"
	provider "github.com/ViBiOh/fibr/pkg/provider"
	gomock "github.com/golang/mock/gomock"
)

// MetadataManager is a mock of MetadataManager interface.
type MetadataManager struct {
	ctrl     *gomock.Controller
	recorder *MetadataManagerMockRecorder
}

// MetadataManagerMockRecorder is the mock recorder for MetadataManager.
type MetadataManagerMockRecorder struct {
	mock *MetadataManager
}

// NewMetadataManager creates a new mock instance.
func NewMetadataManager(ctrl *gomock.Controller) *MetadataManager {
	mock := &MetadataManager{ctrl: ctrl}
	mock.recorder = &MetadataManagerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MetadataManager) EXPECT() *MetadataManagerMockRecorder {
	return m.recorder
}

// GetAggregateFor mocks base method.
func (m *MetadataManager) GetAggregateFor(ctx context.Context, item model.Item) (provider.Aggregate, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAggregateFor", ctx, item)
	ret0, _ := ret[0].(provider.Aggregate)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetAggregateFor indicates an expected call of GetAggregateFor.
func (mr *MetadataManagerMockRecorder) GetAggregateFor(ctx, item interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAggregateFor", reflect.TypeOf((*MetadataManager)(nil).GetAggregateFor), ctx, item)
}

// GetAllAggregateFor mocks base method.
func (m *MetadataManager) GetAllAggregateFor(ctx context.Context, items ...model.Item) (map[string]provider.Aggregate, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx}
	for _, a := range items {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetAllAggregateFor", varargs...)
	ret0, _ := ret[0].(map[string]provider.Aggregate)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetAllAggregateFor indicates an expected call of GetAllAggregateFor.
func (mr *MetadataManagerMockRecorder) GetAllAggregateFor(ctx interface{}, items ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx}, items...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAllAggregateFor", reflect.TypeOf((*MetadataManager)(nil).GetAllAggregateFor), varargs...)
}

// GetAllMetadataFor mocks base method.
func (m *MetadataManager) GetAllMetadataFor(ctx context.Context, items ...model.Item) (map[string]provider.Metadata, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx}
	for _, a := range items {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetAllMetadataFor", varargs...)
	ret0, _ := ret[0].(map[string]provider.Metadata)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetAllMetadataFor indicates an expected call of GetAllMetadataFor.
func (mr *MetadataManagerMockRecorder) GetAllMetadataFor(ctx interface{}, items ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx}, items...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAllMetadataFor", reflect.TypeOf((*MetadataManager)(nil).GetAllMetadataFor), varargs...)
}

// GetMetadataFor mocks base method.
func (m *MetadataManager) GetMetadataFor(ctx context.Context, item model.Item) (provider.Metadata, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetMetadataFor", ctx, item)
	ret0, _ := ret[0].(provider.Metadata)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetMetadataFor indicates an expected call of GetMetadataFor.
func (mr *MetadataManagerMockRecorder) GetMetadataFor(ctx, item interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMetadataFor", reflect.TypeOf((*MetadataManager)(nil).GetMetadataFor), ctx, item)
}

// ListDir mocks base method.
func (m *MetadataManager) ListDir(ctx context.Context, item model.Item) ([]model.Item, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListDir", ctx, item)
	ret0, _ := ret[0].([]model.Item)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListDir indicates an expected call of ListDir.
func (mr *MetadataManagerMockRecorder) ListDir(ctx, item interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListDir", reflect.TypeOf((*MetadataManager)(nil).ListDir), ctx, item)
}

// SaveAggregateFor mocks base method.
func (m *MetadataManager) SaveAggregateFor(ctx context.Context, item model.Item, aggregate provider.Aggregate) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SaveAggregateFor", ctx, item, aggregate)
	ret0, _ := ret[0].(error)
	return ret0
}

// SaveAggregateFor indicates an expected call of SaveAggregateFor.
func (mr *MetadataManagerMockRecorder) SaveAggregateFor(ctx, item, aggregate interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveAggregateFor", reflect.TypeOf((*MetadataManager)(nil).SaveAggregateFor), ctx, item, aggregate)
}

// Update mocks base method.
func (m *MetadataManager) Update(ctx context.Context, item model.Item, opts ...provider.MetadataAction) (provider.Metadata, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, item}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Update", varargs...)
	ret0, _ := ret[0].(provider.Metadata)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Update indicates an expected call of Update.
func (mr *MetadataManagerMockRecorder) Update(ctx, item interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, item}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MetadataManager)(nil).Update), varargs...)
}
