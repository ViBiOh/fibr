{{ define "upload-modal" }}
  <script type="text/javascript" nonce="{{ .nonce }}">
    /**
     * Drag'n drop.
     */
    const dropZone = document.getElementsByTagName('body')[0];

    let fileInput;
    let uploadList;
    let cancelButton;

    /**
     * Noop function for event handler.
     * @param  {Object} e Event
     */
    function eventNoop(e) {
      e.preventDefault();
      e.stopPropagation();
    }

    dropZone.addEventListener('dragover', eventNoop);
    dropZone.addEventListener('dragleave', eventNoop);
    dropZone.addEventListener('drop', (e) => {
      eventNoop(e);

      window.location.hash = '#upload-modal';
      if (fileInput) {
        fileInput.files = e.dataTransfer.files;
        fileInput.dispatchEvent(new Event('change'));
      }
    });

    /**
     * Convert an ArrayBuffer to a HexString
     * @param  {ArrayBuffer} buffer ArrayBuffer to convert
     * @return {String}      Matching hex string
     */
    function bufferToHex(buffer) {
      return Array.prototype.map
        .call(new Uint8Array(buffer), (x) => `00${x.toString(16)}`.slice(-2))
        .join('');
    }

    /**
     * Compute the sha1 on input.
     * @param  {Object}          data Data to hash
     * @return {Promise<String>}      Promise that will resolve the sha1 string
     */
    async function sha1(data) {
      const buffer = await crypto.subtle.digest(
        'SHA-1',
        new TextEncoder('utf-8').encode(data),
      );
      return bufferToHex(buffer);
    }

    /**
     * Generate file message id.
     * @param  {File} file       File to generate id from.
     * @return {Promise<String>} Promise that will resolve the message id.
     */
    async function fileMessageId(file) {
      const hash = await sha1(
        JSON.stringify({
          name: file.name,
          size: file.size,
          type: file.type,
          lastModified: file.lastModified,
        }),
      );
      return `upload-file-${hash}`;
    }

    /**
     * Get human file size.
     * @param  {Number} number Size in bytes
     * @return {String}        Human readable size
     */
    function humanFileSize(number) {
      if (number < 1024) {
        return number + 'bytes';
      }

      if (number < 1048576) {
        return (number / 1024).toFixed(0) + ' KB';
      }

      return (number / 1048576).toFixed(0) + ' MB';
    }

    /**
     * Add upload item content to container.
     * @param  {Element} container Container to append item
     * @param  {File}    file      File to generate an item
     */
    async function addUploadItem(container, file) {
      const messageId = await fileMessageId(file);

      const item = document.createElement('div');
      item.id = messageId;
      item.classList.add('flex', 'flex-center', 'margin');

      const itemWrapper = document.createElement('div');
      itemWrapper.classList.add('upload-item');
      item.appendChild(itemWrapper);

      const filename = document.createElement('input');
      filename.id = `${messageId}-filename`;
      filename.classList.add('upload-name', 'full');
      filename.type = 'text';
      filename.value = file.name;
      itemWrapper.appendChild(filename);

      const progressContainer = document.createElement('div');
      progressContainer.classList.add('full', 'flex', 'flex-center');

      const size = document.createElement('em');
      size.innerHTML = humanFileSize(file.size);
      size.style.width = '8rem';
      progressContainer.appendChild(size);

      const progress = document.createElement('progress');
      progress.classList.add('flex-grow', 'margin-left');
      progress.max = 100;
      progress.value = 0;
      progressContainer.appendChild(progress);

      itemWrapper.appendChild(progressContainer);

      const status = document.createElement('span');
      status.classList.add('upload-status');
      item.appendChild(status);

      container.appendChild(item);
    }

    /**
     * Add upload item content to container.
     * @param  {Element} container Container to append item
     * @param  {File}    file      File to generate an item
     * @param  {File}    id        Share ID to generate an item
     */
    async function addShareItem(container, id, file) {
      const item = document.createElement('div');
      item.classList.add('flex', 'flex-center', 'margin');

      const icon = document.createElement('img');
      icon.classList.add('icon');
      icon.src = '{{ url "/svg/share-alt-square?fill=aliceblue" }}';
      icon.alt = `Share ${file.name}`;
      item.appendChild(icon);

      const filename = document.createElement('div');
      filename.classList.add(
        'upload-name',
        'flex-grow',
        'ellipsis',
        'padding-left',
      );

      const prefix = "{{ url "/" }}";

      const link = document.createElement('a');
      link.href = `${prefix}${id}/`;
      link.innerHTML = file.name;
      filename.appendChild(link);

      item.appendChild(filename);

      container.appendChild(item);
    }

    /**
     * Get list of files to upload.
     */
    function getFiles(event) {
      return [].filter
        .call(event.target, (e) => e.nodeName.toLowerCase() === 'input')
        .reduce((acc, cur) => {
          if (cur.type === 'file') {
            acc.files = cur.files;
          } else {
            acc[cur.name] = cur.value;
          }

          return acc;
        }, {});
    }

    /**
     * Add upload message for file
     * @param {File}    file    File to generate message
     * @param {Element} content Content of message
     * @param {String}  style   Style of status
     */
    async function setUploadStatus(file, content, style) {
      const messageId = await fileMessageId(file);

      const container = document.getElementById(messageId);
      if (!container) {
        return;
      }

      const statusContainer = container.querySelector('.upload-status');
      if (!statusContainer) {
        return;
      }

      statusContainer.innerHTML = content;
      statusContainer.classList.add(style);
    }

    let aborter;

    const chunkSize = 1024 * 1024;
    let currentUpload = {};

    /**
     * Upload file by chunks.
     * @param  {String} method   Method for uploading
     * @param  {File} file       File to upload
     * @param  {Boolean} shared  Shared option
     * @param  {Number} duration Duration of share
     * @return {Promise}         Promise of upload
     */
    async function uploadFileByChunks(method, file, shared, duration) {
      const messageId = await fileMessageId(file);

      const container = document.getElementById(messageId);
      let progress;
      if (container) {
        progress = container.querySelector('progress');
      }

      if (file.name !== currentUpload.filename) {
        currentUpload.filename = file.name;
        currentUpload.chunks = [];

        for (let cur = 0; cur < file.size; cur += chunkSize) {
          currentUpload.chunks.push({
            content: file.slice(cur, cur + chunkSize),
            done: false,
          });
        }
      }

      const filenameInput = document.getElementById(`${messageId}-filename`);
      let fileName;
      if (filenameInput && filenameInput.value) {
        fileName = filenameInput.value;
      }

      if (typeof AbortController !== 'undefined') {
        aborter = new AbortController();
      }

      for (var i = 0; i < currentUpload.chunks.length; i++) {
        if (currentUpload.chunks[i].done) {
          continue;
        }

        const formData = new FormData();
        formData.append('method', method);
        formData.append('filename', fileName);
        formData.append('file', currentUpload.chunks[i].content);

        const response = await fetch('', {
          method: 'POST',
          credentials: 'same-origin',
          signal: aborter.signal,
          headers: {
            'X-Chunk-Upload': true,
            'X-Chunk-Number': i + 1,
            Accept: 'text/plain',
          },
          body: formData,
        });

        if (response.status >= 400) {
          const error = await response.text();
          return Promise.reject(error);
        }

        currentUpload.chunks[i].done = true;
        if (progress) {
          progress.value = ((chunkSize * (i + 1)) / file.size) * 100;
        }
      }

      const formData = new FormData();
      formData.append('method', method);
      formData.append('filename', fileName);
      formData.append('share', shared);
      formData.append('duration', duration);
      formData.append('size', file.size);

      const response = await fetch('', {
        method: 'POST',
        credentials: 'same-origin',
        headers: {
          'X-Chunk-Upload': true,
          Accept: 'text/plain',
        },
        body: formData,
      });

      const error = await response.text();
      if (response.status >= 400) {
        return Promise.reject(error);
      } else {
        currentUpload = {};
        return Promise.resolve(error);
      }
    }

    /**
     * Upload file with updating progress indicator.
     * @param  {String} method   Method for uploading
     * @param  {File} file       File to upload
     * @param  {Boolean} shared  Shared option
     * @param  {Number} duration Duration of share
     * @return {Promise}       Promise of upload
     */
    async function uploadFileByXHR(method, file, shared, duration) {
      const messageId = await fileMessageId(file);

      const container = document.getElementById(messageId);
      let progress;
      if (container) {
        progress = container.querySelector('progress');
      }

      const formData = new FormData();
      formData.append('method', method);
      formData.append('share', shared);
      formData.append('duration', duration);

      const filenameInput = document.getElementById(`${messageId}-filename`);
      if (filenameInput && filenameInput.value) {
        formData.append('filename', filenameInput.value);
      }
      formData.append('size', file.size);
      formData.append('file', file);

      return new Promise((resolve, reject) => {
        let xhr = new XMLHttpRequest();
        aborter = xhr;

        if (progress) {
          xhr.upload.addEventListener(
            'progress',
            (e) => (progress.value = parseInt((e.loaded / e.total) * 100, 10)),
            false,
          );
        }

        xhr.addEventListener(
          'readystatechange',
          (e) => {
            if (xhr.readyState === XMLHttpRequest.DONE) {
              if (xhr.status >= 200 && xhr.status < 400) {
                if (progress) {
                  progress.value = 100;
                }

                resolve(xhr.responseText);
                xhr = undefined;
              } else {
                reject(e);
                xhr = undefined;
              }
            } else if (xhr.readyState === XMLHttpRequest.UNSENT) {
              reject(new Error('request aborted'));
              xhr = undefined;
            }
          },
          false,
        );

        xhr.open('POST', '', true);
        xhr.setRequestHeader('Accept', 'text/plain');
        xhr.send(formData);
      });
    }

    {{- if .ChunkUpload }}
    const uploadFile = uploadFileByChunks
    {{- else }}
    const uploadFile = uploadFileByXHR
    {{- end }}

    /**
     * Slice FileList from given index.
     * @param  {String} name Name of the input file element
     * @param  {Integer} index Index for the slice
     */
    function sliceFileList(name, index) {
      const input = document.getElementById(name);
      const newList = new DataTransfer();

      for (; index < input.files.length; index++) {
        newList.items.add(input.files[index]);
      }

      input.files = newList.files;
    }

    /**
     * Handle upload submit
     * @param  {Object} event Submit event
     */
    async function upload(event) {
      event.preventDefault();

      const uploadButton = document.getElementById('upload-button');
      if (uploadButton) {
        replaceContent(uploadButton, generateThrobber(['throbber-white']));
      }

      if (cancelButton) {
        cancelButton.innerHTML = 'Cancel';
      }

      let share = false;
      const uploadShare = document.getElementById('upload-share');
      if (uploadShare) {
        share = uploadShare.checked;
      }

      let duration = 0;
      if (share) {
        const shareDuration = document.getElementById('upload-duration');
        if (shareDuration) {
          duration = shareDuration.value;
        }
      }

      const values = getFiles(event);
      const shares = new Map();

      let success = true;
      for (let i = 0; i < values.files.length; i++) {
        const file = values.files[i];

        try {
          const uploadFilename = await uploadFile(
            values.method,
            file,
            share,
            duration,
          );
          const parts = uploadFilename.split('\n');
          if (parts.length > 1) {
            shares.set(parts[1], file);
          }

          await setUploadStatus(file, '✓', 'success');
        } catch (err) {
          sliceFileList('file', i);
          if (uploadButton) {
            uploadButton.innerHTML = 'Retry';
          }
          await setUploadStatus(file, 'X', 'danger');

          success = false;
          aborter = undefined;

          console.error(err);
          break;
        }
      }

      if (success) {
        if (shares.size) {
          const shareList = document.getElementById('upload-share-list');
          if (shareList) {
            shares.forEach((value, key) => addShareItem(shareList, key, value));
          }
        }

        document.location.hash = '#upload-success';
      } else if (cancelButton) {
        cancelButton.innerHTML = 'Close';
      }

      return false;
    }

    /**
     * Abort current upload.
     */
    function abort(e) {
      e.preventDefault();

      if (aborter) {
        aborter.abort();
        aborter = undefined;

        if (cancelButton) {
          cancelButton.innerHTML = 'Close';
        }
      } else {
        window.location.hash = '';
      }

      return false;
    }

    document.addEventListener('readystatechange', async (event) => {
      if (event.target.readyState === 'complete') {
        fileInput = document.getElementById('file');
        uploadList = document.getElementById('upload-list');
        cancelButton = document.getElementById('upload-cancel');

        if (fileInput) {
          fileInput.classList.add('opacity');
          fileInput.multiple = true;

          fileInput.addEventListener('change', () => {
            window.location.hash = '#upload-modal';

            replaceContent(uploadList);

            for (const file of fileInput.files) {
              addUploadItem(uploadList, file);
            }
          });

          const uploadButtonLink = document.getElementById('upload-button-link');
          if (uploadButtonLink) {
            uploadButtonLink.addEventListener('click', (e) => {
              eventNoop(e);

              fileInput.click();
            });
          }
        }

        const fileInputLabel = document.getElementById('file-label');
        if (fileInputLabel) {
          fileInputLabel.classList.remove('hidden');
          fileInputLabel.innerHTML = 'Choose files...';
        }

        if (uploadList) {
          uploadList.classList.remove('hidden');
        }

        const shareLabel = document.getElementById('upload-share-label');
        if (shareLabel) {
          shareLabel.innerHTML = 'Create a public read-only share on each file for';
        }

        if (cancelButton) {
          cancelButton.addEventListener('click', abort);
        }

        const form = document.getElementById('upload-form');
        if (form) {
          form.addEventListener('submit', upload);
        }
      }
    });
  </script>

  <style type="text/css" nonce="{{ .nonce }}">
    #upload-modal:target,
    #upload-success:target {
      display: flex;
      z-index: 5;
    }

    #upload-modal:target ~ .content,
    #upload-success:target ~ .content {
      pointer-events: none;
    }

    #upload-list {
      margin: 1rem auto;
    }

    #upload-duration {
      width: 5rem;
    }

    .upload-width {
      max-width: 30rem;
    }

    .upload-item {
      display: inline-block;
      width: calc(100% - 2rem);
    }

    .upload-name {
      text-align: left;
    }

    .opacity {
      flex: 0 0;
      opacity: 0;
    }

    .upload-status {
      margin-left: 0.5rem;
      text-align: right;
      width: 2rem;
    }
  </style>

  <div id="upload-modal" class="modal">
    <div class="modal-content">
      <h2 class="flex flex-center header no-margin">
        <span>Upload files</span>
        <span class="flex-grow"></span>
        <a id="upload-cancel" href="#" class="button white small">Close</a>
      </h2>

      <form
        id="upload-form"
        class="flex flex-column flex-grow flex-center scrollable"
        method="post"
        enctype="multipart/form-data"
        action="#"
      >
        <input type="hidden" name="method" value="POST" />

        {{ if .Request.CanShare }}
          <p class="padding no-margin center upload-width">
            <input id="upload-share" type="checkbox" name="share" value="true" />
            <label id="upload-share-label" for="upload-share">Create a public read-only share for</label>
            <input id="upload-duration" type="number" name="duration" value="1" placeholder="Duration" />
            <label for="upload-duration">hours</label>
          </p>
        {{ end }}

        <p class="padding no-margin center upload-width flex flex-center">
          <input id="file" class="full" type="file" name="file" />
          <label id="file-label" for="file" tabindex="0" class="hidden button bg-success">Choose file...</label>
        </p>

        <div id="upload-list" class="hidden upload-width full scrollable"></div>

        <p class="padding no-margin center">
          <button id="upload-button" type="submit" class="button bg-primary">Upload</button>
        </p>
      </form>
    </div>
  </div>

  <div id="upload-success" class="modal">
    <div class="modal-content">
      <h2 class="header success padding">Upload success ✓</h2>

      <div id="upload-share-list" class="upload-width full"></div>

      <p class="padding no-margin center">
        <a href="?redirect&d={{ .Request.Display }}" class="button bg-grey">Close</a>
      </p>
    </div>
  </div>
{{ end }}
